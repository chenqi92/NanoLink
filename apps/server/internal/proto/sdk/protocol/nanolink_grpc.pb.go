// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.0
// - protoc             v6.33.2
// source: sdk/protocol/nanolink.proto

package proto

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	NanoLinkService_Authenticate_FullMethodName   = "/nanolink.NanoLinkService/Authenticate"
	NanoLinkService_StreamMetrics_FullMethodName  = "/nanolink.NanoLinkService/StreamMetrics"
	NanoLinkService_ReportMetrics_FullMethodName  = "/nanolink.NanoLinkService/ReportMetrics"
	NanoLinkService_ExecuteCommand_FullMethodName = "/nanolink.NanoLinkService/ExecuteCommand"
	NanoLinkService_Heartbeat_FullMethodName      = "/nanolink.NanoLinkService/Heartbeat"
	NanoLinkService_SyncMetrics_FullMethodName    = "/nanolink.NanoLinkService/SyncMetrics"
	NanoLinkService_GetAgentInfo_FullMethodName   = "/nanolink.NanoLinkService/GetAgentInfo"
)

// NanoLinkServiceClient is the client API for NanoLinkService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// NanoLinkService is the main gRPC service for Agent-Server communication
type NanoLinkServiceClient interface {
	// Authenticate authenticates the agent and returns permission level
	Authenticate(ctx context.Context, in *AuthRequest, opts ...grpc.CallOption) (*AuthResponse, error)
	// StreamMetrics is a bidirectional stream for metrics upload and command dispatch
	// Agent streams metrics to server, server streams commands to agent
	StreamMetrics(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[MetricsStreamRequest, MetricsStreamResponse], error)
	// ReportMetrics is a simple unary RPC for one-time metrics report
	ReportMetrics(ctx context.Context, in *Metrics, opts ...grpc.CallOption) (*MetricsAck, error)
	// ExecuteCommand sends a command to the agent and waits for result
	ExecuteCommand(ctx context.Context, in *Command, opts ...grpc.CallOption) (*CommandResult, error)
	// Heartbeat keeps the connection alive
	Heartbeat(ctx context.Context, in *HeartbeatRequest, opts ...grpc.CallOption) (*HeartbeatResponse, error)
	// SyncMetrics syncs buffered metrics after reconnection
	SyncMetrics(ctx context.Context, in *MetricsSyncRequest, opts ...grpc.CallOption) (*MetricsSyncResponse, error)
	// GetAgentInfo returns current agent information
	GetAgentInfo(ctx context.Context, in *AgentInfoRequest, opts ...grpc.CallOption) (*AgentInfoResponse, error)
}

type nanoLinkServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewNanoLinkServiceClient(cc grpc.ClientConnInterface) NanoLinkServiceClient {
	return &nanoLinkServiceClient{cc}
}

func (c *nanoLinkServiceClient) Authenticate(ctx context.Context, in *AuthRequest, opts ...grpc.CallOption) (*AuthResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AuthResponse)
	err := c.cc.Invoke(ctx, NanoLinkService_Authenticate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nanoLinkServiceClient) StreamMetrics(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[MetricsStreamRequest, MetricsStreamResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &NanoLinkService_ServiceDesc.Streams[0], NanoLinkService_StreamMetrics_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[MetricsStreamRequest, MetricsStreamResponse]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type NanoLinkService_StreamMetricsClient = grpc.BidiStreamingClient[MetricsStreamRequest, MetricsStreamResponse]

func (c *nanoLinkServiceClient) ReportMetrics(ctx context.Context, in *Metrics, opts ...grpc.CallOption) (*MetricsAck, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MetricsAck)
	err := c.cc.Invoke(ctx, NanoLinkService_ReportMetrics_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nanoLinkServiceClient) ExecuteCommand(ctx context.Context, in *Command, opts ...grpc.CallOption) (*CommandResult, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CommandResult)
	err := c.cc.Invoke(ctx, NanoLinkService_ExecuteCommand_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nanoLinkServiceClient) Heartbeat(ctx context.Context, in *HeartbeatRequest, opts ...grpc.CallOption) (*HeartbeatResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HeartbeatResponse)
	err := c.cc.Invoke(ctx, NanoLinkService_Heartbeat_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nanoLinkServiceClient) SyncMetrics(ctx context.Context, in *MetricsSyncRequest, opts ...grpc.CallOption) (*MetricsSyncResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MetricsSyncResponse)
	err := c.cc.Invoke(ctx, NanoLinkService_SyncMetrics_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nanoLinkServiceClient) GetAgentInfo(ctx context.Context, in *AgentInfoRequest, opts ...grpc.CallOption) (*AgentInfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AgentInfoResponse)
	err := c.cc.Invoke(ctx, NanoLinkService_GetAgentInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NanoLinkServiceServer is the server API for NanoLinkService service.
// All implementations must embed UnimplementedNanoLinkServiceServer
// for forward compatibility.
//
// NanoLinkService is the main gRPC service for Agent-Server communication
type NanoLinkServiceServer interface {
	// Authenticate authenticates the agent and returns permission level
	Authenticate(context.Context, *AuthRequest) (*AuthResponse, error)
	// StreamMetrics is a bidirectional stream for metrics upload and command dispatch
	// Agent streams metrics to server, server streams commands to agent
	StreamMetrics(grpc.BidiStreamingServer[MetricsStreamRequest, MetricsStreamResponse]) error
	// ReportMetrics is a simple unary RPC for one-time metrics report
	ReportMetrics(context.Context, *Metrics) (*MetricsAck, error)
	// ExecuteCommand sends a command to the agent and waits for result
	ExecuteCommand(context.Context, *Command) (*CommandResult, error)
	// Heartbeat keeps the connection alive
	Heartbeat(context.Context, *HeartbeatRequest) (*HeartbeatResponse, error)
	// SyncMetrics syncs buffered metrics after reconnection
	SyncMetrics(context.Context, *MetricsSyncRequest) (*MetricsSyncResponse, error)
	// GetAgentInfo returns current agent information
	GetAgentInfo(context.Context, *AgentInfoRequest) (*AgentInfoResponse, error)
	mustEmbedUnimplementedNanoLinkServiceServer()
}

// UnimplementedNanoLinkServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedNanoLinkServiceServer struct{}

func (UnimplementedNanoLinkServiceServer) Authenticate(context.Context, *AuthRequest) (*AuthResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Authenticate not implemented")
}
func (UnimplementedNanoLinkServiceServer) StreamMetrics(grpc.BidiStreamingServer[MetricsStreamRequest, MetricsStreamResponse]) error {
	return status.Error(codes.Unimplemented, "method StreamMetrics not implemented")
}
func (UnimplementedNanoLinkServiceServer) ReportMetrics(context.Context, *Metrics) (*MetricsAck, error) {
	return nil, status.Error(codes.Unimplemented, "method ReportMetrics not implemented")
}
func (UnimplementedNanoLinkServiceServer) ExecuteCommand(context.Context, *Command) (*CommandResult, error) {
	return nil, status.Error(codes.Unimplemented, "method ExecuteCommand not implemented")
}
func (UnimplementedNanoLinkServiceServer) Heartbeat(context.Context, *HeartbeatRequest) (*HeartbeatResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Heartbeat not implemented")
}
func (UnimplementedNanoLinkServiceServer) SyncMetrics(context.Context, *MetricsSyncRequest) (*MetricsSyncResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SyncMetrics not implemented")
}
func (UnimplementedNanoLinkServiceServer) GetAgentInfo(context.Context, *AgentInfoRequest) (*AgentInfoResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetAgentInfo not implemented")
}
func (UnimplementedNanoLinkServiceServer) mustEmbedUnimplementedNanoLinkServiceServer() {}
func (UnimplementedNanoLinkServiceServer) testEmbeddedByValue()                         {}

// UnsafeNanoLinkServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NanoLinkServiceServer will
// result in compilation errors.
type UnsafeNanoLinkServiceServer interface {
	mustEmbedUnimplementedNanoLinkServiceServer()
}

func RegisterNanoLinkServiceServer(s grpc.ServiceRegistrar, srv NanoLinkServiceServer) {
	// If the following call panics, it indicates UnimplementedNanoLinkServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&NanoLinkService_ServiceDesc, srv)
}

func _NanoLinkService_Authenticate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuthRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NanoLinkServiceServer).Authenticate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NanoLinkService_Authenticate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NanoLinkServiceServer).Authenticate(ctx, req.(*AuthRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NanoLinkService_StreamMetrics_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(NanoLinkServiceServer).StreamMetrics(&grpc.GenericServerStream[MetricsStreamRequest, MetricsStreamResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type NanoLinkService_StreamMetricsServer = grpc.BidiStreamingServer[MetricsStreamRequest, MetricsStreamResponse]

func _NanoLinkService_ReportMetrics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Metrics)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NanoLinkServiceServer).ReportMetrics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NanoLinkService_ReportMetrics_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NanoLinkServiceServer).ReportMetrics(ctx, req.(*Metrics))
	}
	return interceptor(ctx, in, info, handler)
}

func _NanoLinkService_ExecuteCommand_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Command)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NanoLinkServiceServer).ExecuteCommand(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NanoLinkService_ExecuteCommand_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NanoLinkServiceServer).ExecuteCommand(ctx, req.(*Command))
	}
	return interceptor(ctx, in, info, handler)
}

func _NanoLinkService_Heartbeat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HeartbeatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NanoLinkServiceServer).Heartbeat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NanoLinkService_Heartbeat_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NanoLinkServiceServer).Heartbeat(ctx, req.(*HeartbeatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NanoLinkService_SyncMetrics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MetricsSyncRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NanoLinkServiceServer).SyncMetrics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NanoLinkService_SyncMetrics_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NanoLinkServiceServer).SyncMetrics(ctx, req.(*MetricsSyncRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NanoLinkService_GetAgentInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AgentInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NanoLinkServiceServer).GetAgentInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NanoLinkService_GetAgentInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NanoLinkServiceServer).GetAgentInfo(ctx, req.(*AgentInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// NanoLinkService_ServiceDesc is the grpc.ServiceDesc for NanoLinkService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var NanoLinkService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "nanolink.NanoLinkService",
	HandlerType: (*NanoLinkServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Authenticate",
			Handler:    _NanoLinkService_Authenticate_Handler,
		},
		{
			MethodName: "ReportMetrics",
			Handler:    _NanoLinkService_ReportMetrics_Handler,
		},
		{
			MethodName: "ExecuteCommand",
			Handler:    _NanoLinkService_ExecuteCommand_Handler,
		},
		{
			MethodName: "Heartbeat",
			Handler:    _NanoLinkService_Heartbeat_Handler,
		},
		{
			MethodName: "SyncMetrics",
			Handler:    _NanoLinkService_SyncMetrics_Handler,
		},
		{
			MethodName: "GetAgentInfo",
			Handler:    _NanoLinkService_GetAgentInfo_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamMetrics",
			Handler:       _NanoLinkService_StreamMetrics_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "sdk/protocol/nanolink.proto",
}

const (
	DashboardService_WatchAgents_FullMethodName     = "/nanolink.DashboardService/WatchAgents"
	DashboardService_WatchMetrics_FullMethodName    = "/nanolink.DashboardService/WatchMetrics"
	DashboardService_GetAgents_FullMethodName       = "/nanolink.DashboardService/GetAgents"
	DashboardService_GetAgentMetrics_FullMethodName = "/nanolink.DashboardService/GetAgentMetrics"
	DashboardService_SendCommand_FullMethodName     = "/nanolink.DashboardService/SendCommand"
)

// DashboardServiceClient is the client API for DashboardService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// DashboardService provides real-time data for web dashboards
type DashboardServiceClient interface {
	// WatchAgents streams agent connection/disconnection events
	WatchAgents(ctx context.Context, in *WatchAgentsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[AgentEvent], error)
	// WatchMetrics streams real-time metrics for specified agents
	WatchMetrics(ctx context.Context, in *WatchMetricsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Metrics], error)
	// GetAgents returns list of connected agents
	GetAgents(ctx context.Context, in *GetAgentsRequest, opts ...grpc.CallOption) (*GetAgentsResponse, error)
	// GetAgentMetrics returns current metrics for an agent
	GetAgentMetrics(ctx context.Context, in *GetAgentMetricsRequest, opts ...grpc.CallOption) (*Metrics, error)
	// SendCommand sends command to agent through dashboard
	SendCommand(ctx context.Context, in *DashboardCommandRequest, opts ...grpc.CallOption) (*CommandResult, error)
}

type dashboardServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewDashboardServiceClient(cc grpc.ClientConnInterface) DashboardServiceClient {
	return &dashboardServiceClient{cc}
}

func (c *dashboardServiceClient) WatchAgents(ctx context.Context, in *WatchAgentsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[AgentEvent], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &DashboardService_ServiceDesc.Streams[0], DashboardService_WatchAgents_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[WatchAgentsRequest, AgentEvent]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type DashboardService_WatchAgentsClient = grpc.ServerStreamingClient[AgentEvent]

func (c *dashboardServiceClient) WatchMetrics(ctx context.Context, in *WatchMetricsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Metrics], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &DashboardService_ServiceDesc.Streams[1], DashboardService_WatchMetrics_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[WatchMetricsRequest, Metrics]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type DashboardService_WatchMetricsClient = grpc.ServerStreamingClient[Metrics]

func (c *dashboardServiceClient) GetAgents(ctx context.Context, in *GetAgentsRequest, opts ...grpc.CallOption) (*GetAgentsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetAgentsResponse)
	err := c.cc.Invoke(ctx, DashboardService_GetAgents_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) GetAgentMetrics(ctx context.Context, in *GetAgentMetricsRequest, opts ...grpc.CallOption) (*Metrics, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Metrics)
	err := c.cc.Invoke(ctx, DashboardService_GetAgentMetrics_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) SendCommand(ctx context.Context, in *DashboardCommandRequest, opts ...grpc.CallOption) (*CommandResult, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CommandResult)
	err := c.cc.Invoke(ctx, DashboardService_SendCommand_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DashboardServiceServer is the server API for DashboardService service.
// All implementations must embed UnimplementedDashboardServiceServer
// for forward compatibility.
//
// DashboardService provides real-time data for web dashboards
type DashboardServiceServer interface {
	// WatchAgents streams agent connection/disconnection events
	WatchAgents(*WatchAgentsRequest, grpc.ServerStreamingServer[AgentEvent]) error
	// WatchMetrics streams real-time metrics for specified agents
	WatchMetrics(*WatchMetricsRequest, grpc.ServerStreamingServer[Metrics]) error
	// GetAgents returns list of connected agents
	GetAgents(context.Context, *GetAgentsRequest) (*GetAgentsResponse, error)
	// GetAgentMetrics returns current metrics for an agent
	GetAgentMetrics(context.Context, *GetAgentMetricsRequest) (*Metrics, error)
	// SendCommand sends command to agent through dashboard
	SendCommand(context.Context, *DashboardCommandRequest) (*CommandResult, error)
	mustEmbedUnimplementedDashboardServiceServer()
}

// UnimplementedDashboardServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedDashboardServiceServer struct{}

func (UnimplementedDashboardServiceServer) WatchAgents(*WatchAgentsRequest, grpc.ServerStreamingServer[AgentEvent]) error {
	return status.Error(codes.Unimplemented, "method WatchAgents not implemented")
}
func (UnimplementedDashboardServiceServer) WatchMetrics(*WatchMetricsRequest, grpc.ServerStreamingServer[Metrics]) error {
	return status.Error(codes.Unimplemented, "method WatchMetrics not implemented")
}
func (UnimplementedDashboardServiceServer) GetAgents(context.Context, *GetAgentsRequest) (*GetAgentsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetAgents not implemented")
}
func (UnimplementedDashboardServiceServer) GetAgentMetrics(context.Context, *GetAgentMetricsRequest) (*Metrics, error) {
	return nil, status.Error(codes.Unimplemented, "method GetAgentMetrics not implemented")
}
func (UnimplementedDashboardServiceServer) SendCommand(context.Context, *DashboardCommandRequest) (*CommandResult, error) {
	return nil, status.Error(codes.Unimplemented, "method SendCommand not implemented")
}
func (UnimplementedDashboardServiceServer) mustEmbedUnimplementedDashboardServiceServer() {}
func (UnimplementedDashboardServiceServer) testEmbeddedByValue()                          {}

// UnsafeDashboardServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DashboardServiceServer will
// result in compilation errors.
type UnsafeDashboardServiceServer interface {
	mustEmbedUnimplementedDashboardServiceServer()
}

func RegisterDashboardServiceServer(s grpc.ServiceRegistrar, srv DashboardServiceServer) {
	// If the following call panics, it indicates UnimplementedDashboardServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&DashboardService_ServiceDesc, srv)
}

func _DashboardService_WatchAgents_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(WatchAgentsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DashboardServiceServer).WatchAgents(m, &grpc.GenericServerStream[WatchAgentsRequest, AgentEvent]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type DashboardService_WatchAgentsServer = grpc.ServerStreamingServer[AgentEvent]

func _DashboardService_WatchMetrics_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(WatchMetricsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DashboardServiceServer).WatchMetrics(m, &grpc.GenericServerStream[WatchMetricsRequest, Metrics]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type DashboardService_WatchMetricsServer = grpc.ServerStreamingServer[Metrics]

func _DashboardService_GetAgents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAgentsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).GetAgents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_GetAgents_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).GetAgents(ctx, req.(*GetAgentsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_GetAgentMetrics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAgentMetricsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).GetAgentMetrics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_GetAgentMetrics_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).GetAgentMetrics(ctx, req.(*GetAgentMetricsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_SendCommand_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DashboardCommandRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).SendCommand(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_SendCommand_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).SendCommand(ctx, req.(*DashboardCommandRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// DashboardService_ServiceDesc is the grpc.ServiceDesc for DashboardService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DashboardService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "nanolink.DashboardService",
	HandlerType: (*DashboardServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetAgents",
			Handler:    _DashboardService_GetAgents_Handler,
		},
		{
			MethodName: "GetAgentMetrics",
			Handler:    _DashboardService_GetAgentMetrics_Handler,
		},
		{
			MethodName: "SendCommand",
			Handler:    _DashboardService_SendCommand_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "WatchAgents",
			Handler:       _DashboardService_WatchAgents_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "WatchMetrics",
			Handler:       _DashboardService_WatchMetrics_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "sdk/protocol/nanolink.proto",
}
